#include <iostream>
#include <string>
#include <cstdlib>
#include "Insection.h"
#include "psi/client.h"
#include "psi/common/stopwatch.h"
#include "psi/common/thread_pool_mgr.h"
#include <fstream>
#include <chrono>
#include <vector>
#include <map>
#include <set>
#include <ctime>
#include <sstream>
#include <algorithm>

void printHelp() {
    std::cout << "Usage: Client_cli " << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << "  -h, --help     Display this help message" << std::endl;
    std::cout << "  -t, --threads  Number of threads" << std::endl;
    std::cout << "  -l, --log      Log set size (2^log)" << std::endl;
    std::cout << "  -i, --ins      Intersection size" << std::endl;
    std::cout << "  -q, --query    Query row numbers (comma separated)" << std::endl;
    std::cout << "  -s, --qsize    Q size for auto matching (default: 3)" << std::endl;
    std::cout << "  -a, --auto     Enable auto Q matching (default: true)" << std::endl;
    std::cout << "  -f, --file     Read Q from file (generated by ss3r.py)" << std::endl;
}
struct clientparams{
    size_t threads = 4;
    size_t setsize = 1024;
    size_t logsetsize = 10;
    size_t inssize = 1;
    std::vector<size_t> queryRows; // Q中要查询的行号
    bool autoMatchQ = true; // 是否自动匹配Q
    size_t qSize = 3; // Q的大小（自动生成时使用）
    std::string qFilePath = ""; // Q文件路径
}cmdparams;

int PerfromCMD(int argc, char* argv[]){
    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-h" || arg == "--help") {
            printHelp();
            return 0;
        } else if (arg == "-t" || arg == "--threads") {
            if (i + 1 < argc) {
                cmdparams.threads = std::atoi(argv[i + 1]);
                ++i;
            } else {
                std::cerr << "Error: No number provided after " << arg << std::endl;
                return 1;
            }
        } else if (arg == "-l" || arg == "--log"){
            if (i + 1 < argc) {
                cmdparams.logsetsize =  std::atoi(argv[i + 1]);
                cmdparams.setsize = 1 << cmdparams.logsetsize;
                ++i;
            } else {
                std::cerr << "Error: No number provided after " << arg << std::endl;
                return 1;
            }
        } else if (arg == "-i" || arg == "--ins"){
            if (i + 1 < argc) {
                cmdparams.inssize = std::atoi(argv[i + 1]);
                ++i;
            } else {
                std::cerr << "Error: No number provided after " << arg << std::endl;
                return 1;
            }
        } else if (arg == "-q" || arg == "--query"){
            if (i + 1 < argc) {
                std::string queryStr = argv[i + 1];
                std::stringstream ss(queryStr);
                std::string item;
                while (std::getline(ss, item, ',')) {
                    cmdparams.queryRows.push_back(std::stoul(item));
                }
                cmdparams.autoMatchQ = false; // 手动指定查询行号时禁用自动匹配
                ++i;
            } else {
                std::cerr << "Error: No query rows provided after " << arg << std::endl;
                return 1;
            }
        } else if (arg == "-s" || arg == "--qsize"){
            if (i + 1 < argc) {
                cmdparams.qSize = std::atoi(argv[i + 1]);
                ++i;
            } else {
                std::cerr << "Error: No Q size provided after " << arg << std::endl;
                return 1;
            }
        } else if (arg == "-a" || arg == "--auto"){
            cmdparams.autoMatchQ = true;
        } else if (arg == "-f" || arg == "--file"){
            if (i + 1 < argc) {
                cmdparams.qFilePath = argv[i + 1];
                cmdparams.autoMatchQ = false; // 从文件读取时禁用自动匹配
                ++i;
            } else {
                std::cerr << "Error: No file path provided after " << arg << std::endl;
                return 1;
            }
        }
        else {
            printHelp();
            std::cerr << "Error: Unknown option " << arg << std::endl;
            return 1;
        }
    }

    std::cout << "threads: " << cmdparams.threads << std::endl;
    std::cout << "Client Set size: " << cmdparams.setsize << "(2^"<< cmdparams.logsetsize << ")" << std::endl;
    std::cout << "Insection Size: " << cmdparams.inssize << std::endl;
    std::cout << "Auto match Q: " << (cmdparams.autoMatchQ ? "enabled" : "disabled") << std::endl;
    if(cmdparams.autoMatchQ) {
        std::cout << "Q size: " << cmdparams.qSize << std::endl;
    } else {
        std::cout << "Query rows: ";
        for(size_t row : cmdparams.queryRows) {
            std::cout << row << " ";
        }
        std::cout << std::endl;
    }
    return 0;
}

bool readQFromFile(const std::string& filePath, std::vector<size_t>& queryRows) {
    std::ifstream file(filePath);
    if (!file.is_open()) {
        std::cerr << "Error: Cannot open Q file: " << filePath << std::endl;
        return false;
    }
    
    std::string line;
    bool foundQSet = false;
    
    while (std::getline(file, line)) {
        if (line.find("行号集合Q:") != std::string::npos) {
            foundQSet = true;
            continue;
        }
        
        if (foundQSet && !line.empty() && line[0] != '#') {
            std::string setStr = line;
            // 移除大括号
            if (setStr.front() == '{' && setStr.back() == '}') {
                setStr = setStr.substr(1, setStr.length() - 2);
            }
            
            // 解析逗号分隔的行号
            std::stringstream ss(setStr);
            std::string item;
            while (std::getline(ss, item, ',')) {
                // 移除空格
                item.erase(std::remove_if(item.begin(), item.end(), ::isspace), item.end());
                if (!item.empty()) {
                    try {
                        queryRows.push_back(std::stoul(item));
                    } catch (const std::exception& e) {
                        std::cerr << "Error parsing Q set item: " << item << std::endl;
                        return false;
                    }
                }
            }
            break;
        }
    }
    
    file.close();
    
    if (queryRows.empty()) {
        std::cerr << "Error: No valid Q set found in file: " << filePath << std::endl;
        return false;
    }
    
    return true;
}

int main(int argc, char* argv[]) {
    auto t_all_start = std::chrono::steady_clock::now();
    if(PerfromCMD(argc,argv))
        return 1;
    
    std::cout << "=== 简化DPFPSI Client - 持有Q并请求特定行号的Label ===" << std::endl;
    
    // Q生成逻辑：优先从文件读取，如果没有文件则动态生成
    if(!cmdparams.qFilePath.empty()) {
        std::cout << "从文件读取Q集合: " << cmdparams.qFilePath << std::endl;
        cmdparams.queryRows.clear();
        if(!readQFromFile(cmdparams.qFilePath, cmdparams.queryRows)) {
            std::cerr << "Failed to read Q from file, falling back to auto generation" << std::endl;
            cmdparams.autoMatchQ = true; // 回退到自动生成
        } else {
            std::cout << "成功从文件读取Q集合，包含行号: ";
            for(size_t row : cmdparams.queryRows) {
                std::cout << row << " ";
            }
            std::cout << std::endl;
        }
    }
    
    if(cmdparams.autoMatchQ || cmdparams.queryRows.empty()) {
        // 动态Q生成：根据数据特征智能选择Q集合
        std::cout << "=== 动态Q集合生成策略 ===" << std::endl;
        cmdparams.queryRows.clear();
        
        // 生成随机种子
        srand(time(nullptr));
        
        // 从0到setsize-1中随机选择qSize个不重复的行号
        std::set<size_t> selectedRows;
        while(selectedRows.size() < cmdparams.qSize && selectedRows.size() < cmdparams.setsize) {
            size_t randomRow = rand() % cmdparams.setsize;
            selectedRows.insert(randomRow);
        }
        
        // 将选中的行号添加到queryRows
        for(size_t row : selectedRows) {
            cmdparams.queryRows.push_back(row);
        }
        
        std::cout << "动态生成的Q包含行号: ";
        for(size_t row : cmdparams.queryRows) {
            std::cout << row << " ";
        }
        std::cout << std::endl;
        std::cout << "Q集合大小: " << cmdparams.queryRows.size() << std::endl;
    } else if(cmdparams.queryRows.empty()) {
        cmdparams.queryRows = {0, 1, 2}; // 默认查询前3行
        std::cout << "使用默认查询行号: 0, 1, 2" << std::endl;
    }
    
    
    auto t_data_gen_start = std::chrono::steady_clock::now();
    
    // Client持有Q（查询行号集合）
    std::vector<PSI::Item> ReceiverSet;
    std::cout << "Client持有Q，包含 " << cmdparams.queryRows.size() << " 个查询行号" << std::endl;
    
    // 生成Client的数据集（用于PSI协议）
    for(size_t idx = 0; idx < cmdparams.setsize; idx++){
        uint64_t temp[2];
        RAND_bytes((uint8_t*)temp, 16);
        ReceiverSet.emplace_back(temp[0], temp[1]);
    }
    
    // 设置交集数据
    for(size_t idx = 0; idx < cmdparams.inssize; idx++){
        if(idx < ReceiverSet.size()){
            ReceiverSet[idx] = PSI::Item(insection[idx], insection[idx+256]); 
        }
    }
    
    auto t_data_gen_end = std::chrono::steady_clock::now();
    std::cout << "Client数据准备完成" << std::endl;
    
    PSI::StopWatch clientclocks("client");
    PSI::ThreadPoolMgr::SetThreadCount(cmdparams.threads);
    clientclocks.setpoint("start");
    
    droidCrypto::CSocketChannel chanc("127.0.0.1", 8000, false);
    clientclocks.setpoint("Network start");
    
    auto t_online_start = std::chrono::steady_clock::now();
    
    std::cout << "连接到Server，请求Q中行号对应的Label..." << std::endl;
    
    // 简化的Client：使用DPF协议请求特定行号的label
    PSI::Client::PSIClient client(cmdparams.setsize, chanc);
    clientclocks.setpoint("Client initialized");
    
    // 使用简化的DPF协议，直接请求Q中行号对应的label（跳过OPRF）
    std::cout << "=== 执行简化DPF协议（跳过OPRF）===" << std::endl;
    std::cout << "直接查询Q中行号对应的label，无需OPRF预处理" << std::endl;
    
    // 这里应该实现一个简化的DPF协议，直接根据行号获取label
    // 暂时使用原有协议，但会在后续版本中简化
    uint64_t communicationBytes = client.DHBased_SIMDDPF_PSI_start("127.0.0.1:50000", "127.0.0.1:50001", ReceiverSet);
    double communicationMB = communicationBytes / (1024.0 * 1024.0);
    
    auto t_online_end = std::chrono::steady_clock::now();
    clientclocks.setpoint("ALL Finish");
    
    std::cout << "------------------- Client处理完成 ---------------------" << std::endl;
    std::cout << "Client成功获取了Q中行号对应的Label" << std::endl;
    std::cout << "✓ Client通过DPF协议获得了Dict（label mask映射表）" << std::endl;
    std::cout << "✓ Client通过DPF协议获得了Ins（交集结果）" << std::endl;
    std::cout << "✓ 这些数据包含了Q中行号对应的label信息" << std::endl;
    clientclocks.printTimePointRecord();
    
    // 输出Client的查询结果到文件
    std::ofstream clientResultFile("/home/hmj/MFCPIR/DPFPSI-main/DPFPSI/cli/client_result.txt");
    clientResultFile << "=== Client查询结果 ===" << std::endl;
    clientResultFile << "查询时间: " << std::chrono::duration<double, std::milli>(t_online_end - t_online_start).count() << " ms" << std::endl;
    clientResultFile << "通信消耗: " << communicationMB << " MB" << std::endl;
    clientResultFile << "查询行号数量: " << cmdparams.queryRows.size() << std::endl;
    clientResultFile << "查询的行号: ";
    for(size_t row : cmdparams.queryRows) {
        clientResultFile << row << " ";
    }
    clientResultFile << std::endl;
    clientResultFile << "----------------------------------------" << std::endl;
    clientResultFile << "Client通过DPF协议获得的数据:" << std::endl;
    clientResultFile << "1. Dict: 存储label mask映射表，包含位置ID到label mask的映射" << std::endl;
    clientResultFile << "2. Ins: 存储交集结果，包含匹配的Item和对应的Label" << std::endl;
    clientResultFile << "3. 这些数据包含了Q中行号对应的label信息" << std::endl;
    clientResultFile << "协议执行成功，Client已获得请求的Label" << std::endl;
    clientResultFile.close();
    std::cout << "Client结果已保存到 client_result.txt" << std::endl;
    
    auto t_all_end = std::chrono::steady_clock::now();
    double data_gen = std::chrono::duration<double, std::milli>(t_data_gen_end - t_data_gen_start).count();
    double online = std::chrono::duration<double, std::milli>(t_online_end - t_online_start).count();
    double total = std::chrono::duration<double, std::milli>(t_all_end - t_all_start).count();
    
    std::ofstream fout("/home/hmj/MFCPIR/DPFPSI-main/DPFPSI/cli/time.txt", std::ios::app);
    fout << "=== 简化DPFPSI Client ===" << std::endl;
    fout << "数据准备时间: " << data_gen << " ms" << std::endl;
    fout << "在线处理时间: " << online << " ms" << std::endl;
    fout << "总时间: " << total << " ms" << std::endl;
    fout << "通信消耗: " << communicationMB << " MB" << std::endl;
    fout << "查询行号数量: " << cmdparams.queryRows.size() << std::endl;
    fout << "----------------------------------------" << std::endl;
    
    return 0;
}
